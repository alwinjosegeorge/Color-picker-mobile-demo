<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TrueShade Pro — Color Detector</title>
  <meta name="description" content="Professional color detection — live camera + upload, lock point, continuous tracking, magnifier, persistent history, export CSV/JSON."/>
  <link href="https://fonts.googleapis.com/css?family=Inter:400,700,900&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg1:#071029; --bg2:#0f1724;
      --glass: rgba(255,255,255,0.05);
      --muted: rgba(255,255,255,0.74);
      --accent1:#7c3aed;
      --accent2:#4f46e5;
      --success:#10b981;
      --danger:#ef4444;
      --radius:14px;
      --ui-font: 'Inter', system-ui, "Segoe UI", Arial;
      --card-bg: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.015));
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:var(--ui-font);background:linear-gradient(180deg,var(--bg2),var(--bg1));color:#eef2ff;}
    body {min-height:100vh;display:flex;align-items:center;justify-content:center;padding:0;}
    .app{
      width:980px;max-width:99vw;border-radius:18px;padding:0 0 14px 0;
      background:var(--card-bg);box-shadow:0 18px 50px rgba(2,6,23,0.75);border:1px solid rgba(255,255,255,0.025);
      margin:22px 0;
      transition: box-shadow .25s;
    }
    .navbar{
      display:flex;align-items:center;gap:14px;border-radius:16px 16px 0 0;padding:14px 20px 12px 24px;
      background:linear-gradient(90deg,#0f1724 80%,rgba(124,58,237,0.15));
      box-shadow:0 2px 12px 0 rgba(124,58,237,0.05);
      border-bottom:1.5px solid rgba(124,58,237,0.09);
    }
    .logo{
      width:46px;height:46px;border-radius:10px;
      background:linear-gradient(135deg,var(--accent1),var(--accent2));
      display:flex;align-items:center;justify-content:center;
      font-weight:900;font-size:24px;color:white;
      box-shadow:0 2px 8px rgba(79,70,229,0.13);
      letter-spacing:2px;
    }
    .nav-title{font-size:1.4rem;font-weight:900;letter-spacing:1.5px;}
    .nav-desc{font-size:13px;color:var(--muted);}
    .main{display:grid;grid-template-columns:1fr 340px;gap:18px;padding:14px 20px;}
    .stage{background:#000;border-radius:16px;min-height:410px;position:relative;overflow:hidden;
      border:1.5px solid rgba(255,255,255,0.04);}
    .controls-bar{
      display:flex;gap:9px;align-items:center;padding:12px 10px;
      background:linear-gradient(180deg, rgba(124,58,237,0.04) 0, transparent 80%);
      border-bottom:1.5px solid rgba(255,255,255,0.05);
      font-size:15px;
    }
    .btn{
      padding:10px 15px;border-radius:10px;background:var(--glass);
      border:1px solid rgba(255,255,255,0.05);color:#eef2ff;font-weight:700;cursor:pointer;
      display:inline-flex;gap:8px;align-items:center;
      font-size:15px;transition:box-shadow .13s,background .17s;
    }
    .btn:active{background:rgba(79,70,229,0.13);}
    .btn.primary{background:linear-gradient(90deg,var(--accent1),var(--accent2));box-shadow:0 8px 24px rgba(79,70,229,0.12);}
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.08);}
    .btn.success{background:linear-gradient(90deg,var(--success),#059669);}
    .btn.danger{background:linear-gradient(90deg,var(--danger),#b91c1c);}
    .btn[disabled]{opacity:0.55;pointer-events:none;}
    input[type=file]{display:none}
    .mode-switch{margin-left:auto;display:flex;gap:8px;align-items:center;}
    .toggle{display:flex;align-items:center;gap:6px;font-size:13px;color:var(--muted);}
    .stage-body{position:relative;height:378px;display:flex;align-items:center;justify-content:center;}
    video,.preview-img,canvas{max-width:100%;width:100%;height:100%;object-fit:cover;display:block;}
    .preview-img{display:block;width:100%;height:100%;object-fit:contain;background:#0b0b0b;}
    .center-cross{
      position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      width:76px;height:76px;border-radius:17px;border:2px dashed rgba(255,255,255,0.60);
      display:flex;align-items:center;justify-content:center;z-index:25;pointer-events:none
    }
    .center-dot{width:12px;height:12px;border-radius:50%;background:rgba(255,255,255,0.97);box-shadow:0 2px 8px rgba(0,0,0,0.6);}
    .floating-chip{
      position:absolute;left:50%;transform:translateX(-50%);
      bottom:78px;background:var(--glass);
      padding:10px 16px;border-radius:999px;display:flex;align-items:center;gap:12px;
      border:1px solid rgba(255,255,255,0.06);backdrop-filter: blur(7px);z-index:30;
      transition:opacity .15s,transform .15s;font-size:15px;box-shadow:0 2px 11px 0 rgba(79,70,229,0.13);
    }
    .floating-chip.hidden{opacity:0;transform:translateX(-50%) translateY(8px);pointer-events:none;}
    .swatch{width:28px;height:28px;border-radius:8px;border:1.5px solid rgba(0,0,0,0.22);box-shadow:0 6px 18px rgba(0,0,0,0.36);}
    .fps{font-size:13px;color:var(--muted);}
    .magnifier{
      position:absolute;width:118px;height:118px;border-radius:14px;border:2px solid rgba(255,255,255,0.085);overflow:hidden;z-index:40;display:none;background:#000;
      box-shadow:0 8px 30px rgba(2,6,23,0.62);
    }
    .magnifier canvas{width:100%;height:100%;display:block;transform-origin:center;}
    .panel{padding:0 0 0 3px;display:flex;flex-direction:column;gap:13px;}
    .card{
      background:var(--card-bg);padding:15px 13px 14px 16px;border-radius:12px;
      border:1.5px solid rgba(255,255,255,0.025);
      box-shadow:0 2px 10px 0 rgba(124,58,237,0.03);
      margin-bottom:4px;
    }
    .big-color{display:flex;gap:12px;align-items:center;}
    .big-swatch{width:72px;height:72px;border-radius:12px;border:1.5px solid rgba(255,255,255,0.11);}
    .big-meta{flex:1;}
    .color-name{font-weight:900;font-size:20px;}
    .color-sub{font-size:14px;color:var(--muted);margin-top:6px;}
    .meta-row{display:flex;gap:8px;align-items:center;margin-top:10px;flex-wrap:wrap;}
    .hex{font-weight:900;background:rgba(255,255,255,0.04);padding:6px 12px;border-radius:8px;font-size:15px;}
    .copy-small{padding:7px 11px;border-radius:8px;background:rgba(255,255,255,0.03);cursor:pointer;border:1px solid rgba(255,255,255,0.05);font-size:15px;}
    .copy-small:active{background:var(--accent1);color:white;}
    .history-list{display:flex;flex-direction:column;gap:10px;max-height:170px;overflow:auto;padding-right:3px;}
    .history-item{
      display:flex;gap:9px;align-items:center;padding:9px 6px 9px 5px;
      border-radius:8px;background:rgba(0,0,0,0.17);cursor:pointer;
      border:1px solid rgba(255,255,255,0.025);transition:background .12s;
    }
    .history-item:hover{background:rgba(124,58,237,0.14);}
    .hist-swatch{width:38px;height:38px;border-radius:8px;flex-shrink:0;}
    .hist-meta{flex:1;}
    .hist-name{font-weight:800;}
    .hist-sub{font-size:12px;color:var(--muted);}
    .footer-note{font-size:13px;color:var(--muted);text-align:center;margin-top:8px;}
    
    /* New enhanced features styles */
    .palette-section{margin-bottom:12px;}
    .palette-title{font-size:12px;font-weight:700;color:var(--muted);margin-bottom:6px;}
    .palette-colors{display:flex;gap:6px;flex-wrap:wrap;}
    .palette-color{
      width:32px;height:32px;border-radius:6px;border:1px solid rgba(255,255,255,0.1);
      cursor:pointer;position:relative;transition:transform .1s;
    }
    .palette-color:hover{transform:scale(1.1);}
    .palette-color::after{
      content:attr(data-name);position:absolute;bottom:-20px;left:50%;transform:translateX(-50%);
      font-size:10px;color:var(--muted);white-space:nowrap;pointer-events:none;
    }
    .custom-name-item{
      display:flex;gap:8px;align-items:center;padding:6px;background:rgba(0,0,0,0.1);
      border-radius:6px;margin-bottom:4px;font-size:12px;
    }
    .custom-name-swatch{width:20px;height:20px;border-radius:4px;border:1px solid rgba(255,255,255,0.1);}
    .export-options{display:flex;gap:6px;margin-top:8px;}
    .export-options .btn{font-size:11px;padding:4px 8px;}
    .batch-upload{display:none;margin-top:8px;}
    .batch-preview{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px;}
    .batch-item{width:40px;height:40px;border-radius:6px;border:1px solid rgba(255,255,255,0.1);cursor:pointer;position:relative;}
    .batch-item:hover{transform:scale(1.05);}
    .batch-item::after{content:'×';position:absolute;top:-5px;right:-5px;background:var(--danger);color:white;width:16px;height:16px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:10px;cursor:pointer;}
    
    @media(max-width:900px){
      .app{width:99vw;}
      .main{grid-template-columns:1fr;gap:13px;padding:9px 4vw;}
      .panel{padding-left:0;}
      .card{padding:11px 7px 10px 9px;}
      .navbar{border-radius:0;}
      .big-swatch{width:62px;height:62px;}
      .stage-body{height:220px;}
      .center-cross{width:54px;height:54px;}
      .floating-chip{padding:7px 8vw;}
    }
    @media(max-width:600px){
      .main{padding:6px 1vw;}
      .footer-note{font-size:11px;}
      .color-name{font-size:16px;}
      .big-swatch{width:46px;height:46px;}
      .nav-title{font-size:1.12rem;}
      .card{padding:8px 5px 9px 6px;}
      .controls-bar{font-size:13px;}
      .meta-row{font-size:13px;}
      .hex{font-size:13px;}
      .copy-small{font-size:13px;padding:6px 8px;}
      .history-item{padding:5px 3px;}
      .stage{min-height:180px;}
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="TrueShade Pro color detector">
    <div class="navbar">
      <div class="logo">TS</div>
      <div>
        <div class="nav-title">TrueShade Pro</div>
        <div class="nav-desc">Live camera + Upload — accurate color naming</div>
      </div>
    </div>
    <div class="main">
      <div class="stage">
        <div class="controls-bar">
          <button class="btn primary" id="startStopBtn">Start Camera</button>
          <button class="btn" id="detectNowBtn">Detect Now</button>
          <label class="btn ghost" for="uploadInput">Upload Image
            <input id="uploadInput" type="file" accept="image/*" aria-label="Upload image" />
          </label>
          <button class="btn" id="lockPointBtn" title="Lock the current point (click/tap to set)">Lock Point: Off</button>
          <div class="mode-switch">
            <label class="toggle"><input id="modeCamera" name="mode" type="radio" checked> Camera</label>
            <label class="toggle"><input id="modeUpload" name="mode" type="radio"> Upload</label>
            <label class="toggle"><input id="continuousToggle" type="checkbox"> Continuous</label>
            <label class="toggle"><input id="apiToggle" type="checkbox" title="Use API for enhanced color naming"> API</label>
          </div>
          <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
            <div class="fps" id="fps">— FPS</div>
            <button class="btn" id="batchModeBtn" title="Batch processing mode">Batch</button>
            <button class="btn" id="exportHistory" title="Export color history">Export</button>
            <button class="btn" id="clearHistory" title="Clear color history">Clear</button>
          </div>
        </div>
        <div class="stage-body" id="stageBody" aria-live="polite">
          <video id="video" autoplay playsinline style="display:none"></video>
          <img id="previewImg" class="preview-img" alt="Uploaded preview" style="display:none"/>
          <canvas id="buffer" style="display:none"></canvas>
          <div class="center-cross" aria-hidden="true"><div class="center-dot"></div></div>
          <div class="floating-chip hidden" id="floatingChip" aria-atomic="true" role="status">
            <div class="swatch" id="chipSwatch" style="background:#ff0000"></div>
            <div>
              <div style="font-weight:800" id="chipName">Red</div>
              <div style="font-size:13px;color:var(--muted)" id="chipMeta">RGB (255,0,0) · #FF0000</div>
            </div>
          </div>
          <div class="magnifier" id="magnifier" aria-hidden="true">
            <canvas id="magnCanvas"></canvas>
          </div>
          <div class="batch-upload" id="batchUpload">
            <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px;">
              <label class="btn ghost" for="batchInput" style="font-size:12px;padding:6px 12px;">Select Images
                <input id="batchInput" type="file" accept="image/*" multiple style="display:none;">
              </label>
              <button class="btn" id="processBatchBtn" style="font-size:12px;padding:6px 12px;">Process All</button>
              <button class="btn ghost" id="clearBatchBtn" style="font-size:12px;padding:6px 12px;">Clear</button>
            </div>
            <div class="batch-preview" id="batchPreview"></div>
          </div>
        </div>
      </div>
      <div class="panel">
        <div class="card big-color">
          <div class="big-swatch" id="bigSwatch" style="background:#ff0000"></div>
          <div class="big-meta">
            <div class="color-name" id="colorName">Red</div>
            <div class="color-sub" id="colorSub">RGB (255, 0, 0) · HEX #FF0000</div>
            <div class="meta-row">
              <div class="hex" id="hexLabel">#FF0000</div>
              <button class="copy-small" id="copyHex">Copy HEX</button>
            </div>
            <div class="color-formats" id="colorFormats" style="margin-top:8px;font-size:12px;color:var(--muted);">
              <div>HSL: <span id="hslValue">0°, 100%, 50%</span></div>
              <div>HSV: <span id="hsvValue">0°, 100%, 100%</span></div>
              <div>CMYK: <span id="cmykValue">0%, 100%, 100%, 0%</span></div>
              <div style="margin-top:4px;font-size:10px;opacity:0.7;">Source: <span id="colorSource">Local</span></div>
            </div>
          </div>
        </div>
        
        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <div style="font-weight:800">Color Palettes</div>
            <button class="btn ghost" id="generatePaletteBtn" style="font-size:12px;padding:4px 8px;">Generate</button>
          </div>
          <div id="paletteContainer" style="display:none;">
            <div class="palette-section">
              <div class="palette-title">Complementary</div>
              <div class="palette-colors" id="complementaryPalette"></div>
            </div>
            <div class="palette-section">
              <div class="palette-title">Analogous</div>
              <div class="palette-colors" id="analogousPalette"></div>
            </div>
            <div class="palette-section">
              <div class="palette-title">Triadic</div>
              <div class="palette-colors" id="triadicPalette"></div>
            </div>
            <div class="palette-section">
              <div class="palette-title">Tetradic</div>
              <div class="palette-colors" id="tetradicPalette"></div>
            </div>
          </div>
        </div>

        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <div style="font-weight:800">Color Blindness</div>
            <select id="colorBlindSelect" style="background:var(--glass);border:1px solid rgba(255,255,255,0.1);color:#eef2ff;padding:4px 8px;border-radius:6px;font-size:12px;">
              <option value="normal">Normal</option>
              <option value="protanopia">Protanopia</option>
              <option value="deuteranopia">Deuteranopia</option>
              <option value="tritanopia">Tritanopia</option>
            </select>
          </div>
          <div id="colorBlindPreview" style="display:flex;gap:8px;align-items:center;">
            <div class="swatch" id="normalSwatch" style="width:40px;height:40px;background:#ff0000;"></div>
            <div class="swatch" id="simulatedSwatch" style="width:40px;height:40px;background:#ff0000;"></div>
            <div style="font-size:12px;color:var(--muted);">Normal → Simulated</div>
          </div>
        </div>
        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <div style="font-weight:800">History</div>
            <div style="font-size:13px;color:var(--muted)">Click to apply · Copy quick</div>
          </div>
          <div style="display:flex;gap:8px;margin-bottom:8px;">
            <input type="text" id="historySearch" placeholder="Search colors..." style="flex:1;background:var(--glass);border:1px solid rgba(255,255,255,0.1);color:#eef2ff;padding:6px 8px;border-radius:6px;font-size:12px;">
            <button class="btn ghost" id="clearSearchBtn" style="font-size:12px;padding:6px 8px;">Clear</button>
          </div>
          <div class="history-list" id="historyList" aria-live="polite"></div>
        </div>

        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <div style="font-weight:800">Custom Names</div>
            <button class="btn ghost" id="addCustomNameBtn" style="font-size:12px;padding:4px 8px;">Add Name</button>
          </div>
          <div id="customNamesList" style="max-height:120px;overflow-y:auto;"></div>
        </div>
        <div class="card" style="text-align:center">
          <div style="font-weight:800">Tips & Shortcuts</div>
          <div class="footer-note" style="text-align:left;font-size:11px;line-height:1.4;">
            <div><strong>Basic:</strong> Space=detect, C=continuous, L=lock point</div>
            <div><strong>Enhanced:</strong> P=palette, B=batch, A=API, N=custom name</div>
            <div><strong>Features:</strong> Color blindness simulation, multiple formats (HSL/HSV/CMYK), palette generation, batch processing, custom names, enhanced export (PNG/SVG)</div>
            <div><strong>Mobile:</strong> Touch and mobile fully supported!</div>
          </div>
        </div>
      </div>
    </div>
    <div class="footer-note" style="margin-top:10px">Made with ❤️ — TrueShade Pro</div>
  </div>
  <div aria-live="polite" id="srLive" style="position:absolute;left:-10000px;top:auto;width:1px;height:1px;overflow:hidden;"></div>
  <!-- JavaScript unchanged except for continuous detection delay now 2s -->
  <script>
    // ---------- Full CSS Colors (approx 140) ----------
    const CSS_COLORS = {
      "AliceBlue":"#F0F8FF","AntiqueWhite":"#FAEBD7","Aqua":"#00FFFF","Aquamarine":"#7FFFD4","Azure":"#F0FFFF",
      "Beige":"#F5F5DC","Bisque":"#FFE4C4","Black":"#000000","BlanchedAlmond":"#FFEBCD","Blue":"#0000FF",
      "BlueViolet":"#8A2BE2","Brown":"#A52A2A","BurlyWood":"#DEB887","CadetBlue":"#5F9EA0","Chartreuse":"#7FFF00",
      "Chocolate":"#D2691E","Coral":"#FF7F50","CornflowerBlue":"#6495ED","Cornsilk":"#FFF8DC","Crimson":"#DC143C",
      "Cyan":"#00FFFF","DarkBlue":"#00008B","DarkCyan":"#008B8B","DarkGoldenRod":"#B8860B","DarkGray":"#A9A9A9",
      "DarkGreen":"#006400","DarkKhaki":"#BDB76B","DarkMagenta":"#8B008B","DarkOliveGreen":"#556B2F","DarkOrange":"#FF8C00",
      "DarkOrchid":"#9932CC","DarkRed":"#8B0000","DarkSalmon":"#E9967A","DarkSeaGreen":"#8FBC8F","DarkSlateBlue":"#483D8B",
      "DarkSlateGray":"#2F4F4F","DarkTurquoise":"#00CED1","DarkViolet":"#9400D3","DeepPink":"#FF1493","DeepSkyBlue":"#00BFFF",
      "DimGray":"#696969","DodgerBlue":"#1E90FF","FireBrick":"#B22222","FloralWhite":"#FFFAF0","ForestGreen":"#228B22",
      "Fuchsia":"#FF00FF","Gainsboro":"#DCDCDC","GhostWhite":"#F8F8FF","Gold":"#FFD700","GoldenRod":"#DAA520",
      "Gray":"#808080","Green":"#008000","GreenYellow":"#ADFF2F","HoneyDew":"#F0FFF0","HotPink":"#FF69B4",
      "IndianRed":"#CD5C5C","Indigo":"#4B0082","Ivory":"#FFFFF0","Khaki":"#F0E68C","Lavender":"#E6E6FA",
      "LavenderBlush":"#FFF0F5","LawnGreen":"#7CFC00","LemonChiffon":"#FFFACD","LightBlue":"#ADD8E6","LightCoral":"#F08080",
      "LightCyan":"#E0FFFF","LightGoldenRodYellow":"#FAFAD2","LightGray":"#D3D3D3","LightGreen":"#90EE90","LightPink":"#FFB6C1",
      "LightSalmon":"#FFA07A","LightSeaGreen":"#20B2AA","LightSkyBlue":"#87CEFA","LightSlateGray":"#778899","LightSteelBlue":"#B0C4DE",
      "LightYellow":"#FFFFE0","Lime":"#00FF00","LimeGreen":"#32CD32","Linen":"#FAF0E6","Magenta":"#FF00FF",
      "Maroon":"#800000","MediumAquaMarine":"#66CDAA","MediumBlue":"#0000CD","MediumOrchid":"#BA55D3","MediumPurple":"#9370DB",
      "MediumSeaGreen":"#3CB371","MediumSlateBlue":"#7B68EE","MediumSpringGreen":"#00FA9A","MediumTurquoise":"#48D1CC","MediumVioletRed":"#C71585",
      "MidnightBlue":"#191970","MintCream":"#F5FFFA","MistyRose":"#FFE4E1","Moccasin":"#FFE4B5","NavajoWhite":"#FFDEAD",
      "Navy":"#000080","OldLace":"#FDF5E6","Olive":"#808000","OliveDrab":"#6B8E23","Orange":"#FFA500",
      "OrangeRed":"#FF4500","Orchid":"#DA70D6","PaleGoldenRod":"#EEE8AA","PaleGreen":"#98FB98","PaleTurquoise":"#AFEEEE",
      "PaleVioletRed":"#DB7093","PapayaWhip":"#FFEFD5","PeachPuff":"#FFDAB9","Peru":"#CD853F","Pink":"#FFC0CB",
      "Plum":"#DDA0DD","PowderBlue":"#B0E0E6","Purple":"#800080","RebeccaPurple":"#663399","Red":"#FF0000",
      "RosyBrown":"#BC8F8F","RoyalBlue":"#4169E1","SaddleBrown":"#8B4513","Salmon":"#FA8072","SandyBrown":"#F4A460",
      "SeaGreen":"#2E8B57","SeaShell":"#FFF5EE","Sienna":"#A0522D","Silver":"#C0C0C0","SkyBlue":"#87CEEB",
      "SlateBlue":"#6A5ACD","SlateGray":"#708090","Snow":"#FFFAFA","SpringGreen":"#00FF7F","SteelBlue":"#4682B4",
      "Tan":"#D2B48C","Teal":"#008080","Thistle":"#D8BFD8","Tomato":"#FF6347","Turquoise":"#40E0D0",
      "Violet":"#EE82EE","Wheat":"#F5DEB3","White":"#FFFFFF","WhiteSmoke":"#F5F5F5","Yellow":"#FFFF00","YellowGreen":"#9ACD32"
    };

    // Color math: RGB -> Lab, deltaE76
    function rgbToXyz(r,g,b){
      r/=255; g/=255; b/=255;
      r = r > 0.04045 ? Math.pow((r+0.055)/1.055,2.4) : r/12.92;
      g = g > 0.04045 ? Math.pow((g+0.055)/1.055,2.4) : g/12.92;
      b = b > 0.04045 ? Math.pow((b+0.055)/1.055,2.4) : b/12.92;
      return [
        (r*0.4124 + g*0.3576 + b*0.1805) * 100,
        (r*0.2126 + g*0.7152 + b*0.0722) * 100,
        (r*0.0193 + g*0.1192 + b*0.9505) * 100
      ];
    }
    function xyzToLab(x,y,z){
      const refX = 95.047, refY = 100.000, refZ = 108.883;
      x /= refX; y /= refY; z /= refZ;
      x = x > 0.008856 ? Math.cbrt(x) : (7.787 * x) + (16/116);
      y = y > 0.008856 ? Math.cbrt(y) : (7.787 * y) + (16/116);
      z = z > 0.008856 ? Math.cbrt(z) : (7.787 * z) + (16/116);
      return [ (116 * y) - 16, 500 * (x - y), 200 * (y - z) ];
    }
    function rgbToLab(r,g,b){
      return xyzToLab(...rgbToXyz(r,g,b));
    }
    function deltaE76(labA, labB){
      const dl = labA[0]-labB[0], da = labA[1]-labB[1], db = labA[2]-labB[2];
      return Math.sqrt(dl*dl + da*da + db*db);
    }

    // Additional Color Format Conversions
    function rgbToHsl(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      const max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;
      if (max === min) h = s = 0;
      else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
      }
      return [Math.round(h * 360), Math.round(s * 100), Math.round(l * 100)];
    }

    function rgbToHsv(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      const max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, v = max;
      const d = max - min;
      s = max === 0 ? 0 : d / max;
      if (max === min) h = 0;
      else {
        switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
      }
      return [Math.round(h * 360), Math.round(s * 100), Math.round(v * 100)];
    }

    function rgbToCmyk(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      const k = 1 - Math.max(r, g, b);
      if (k === 1) return [0, 0, 0, 100];
      const c = (1 - r - k) / (1 - k);
      const m = (1 - g - k) / (1 - k);
      const y = (1 - b - k) / (1 - k);
      return [Math.round(c * 100), Math.round(m * 100), Math.round(y * 100), Math.round(k * 100)];
    }

    // Color Palette Generation
    function generatePalette(r, g, b) {
      const hsl = rgbToHsl(r, g, b);
      const h = hsl[0];
      
      return {
        complementary: [
          { name: 'Original', rgb: [r, g, b], hex: rgbToHex(r, g, b) },
          { name: 'Complementary', rgb: hslToRgb((h + 180) % 360, hsl[1], hsl[2]), hex: '' }
        ],
        analogous: [
          { name: 'Original', rgb: [r, g, b], hex: rgbToHex(r, g, b) },
          { name: 'Analogous 1', rgb: hslToRgb((h + 30) % 360, hsl[1], hsl[2]), hex: '' },
          { name: 'Analogous 2', rgb: hslToRgb((h - 30 + 360) % 360, hsl[1], hsl[2]), hex: '' }
        ],
        triadic: [
          { name: 'Original', rgb: [r, g, b], hex: rgbToHex(r, g, b) },
          { name: 'Triadic 1', rgb: hslToRgb((h + 120) % 360, hsl[1], hsl[2]), hex: '' },
          { name: 'Triadic 2', rgb: hslToRgb((h + 240) % 360, hsl[1], hsl[2]), hex: '' }
        ],
        tetradic: [
          { name: 'Original', rgb: [r, g, b], hex: rgbToHex(r, g, b) },
          { name: 'Tetradic 1', rgb: hslToRgb((h + 90) % 360, hsl[1], hsl[2]), hex: '' },
          { name: 'Tetradic 2', rgb: hslToRgb((h + 180) % 360, hsl[1], hsl[2]), hex: '' },
          { name: 'Tetradic 3', rgb: hslToRgb((h + 270) % 360, hsl[1], hsl[2]), hex: '' }
        ]
      };
    }

    function hslToRgb(h, s, l) {
      h /= 360; s /= 100; l /= 100;
      const hue2rgb = (p, q, t) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      };
      if (s === 0) return [Math.round(l * 255), Math.round(l * 255), Math.round(l * 255)];
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      return [
        Math.round(hue2rgb(p, q, h + 1/3) * 255),
        Math.round(hue2rgb(p, q, h) * 255),
        Math.round(hue2rgb(p, q, h - 1/3) * 255)
      ];
    }

    // Color Blindness Simulation
    function simulateColorBlindness(r, g, b, type) {
      switch (type) {
        case 'protanopia':
          return [0.567 * r + 0.433 * g, 0.558 * r + 0.442 * g, 0.242 * g + 0.758 * b];
        case 'deuteranopia':
          return [0.625 * r + 0.375 * g, 0.7 * r + 0.3 * g, 0.3 * g + 0.7 * b];
        case 'tritanopia':
          return [0.95 * r + 0.05 * g, 0.433 * r + 0.567 * g, 0.475 * g + 0.525 * b];
        default:
          return [r, g, b];
      }
    }

    // Find closest named color
    const CALC_CACHE = {};
    const API_CACHE = {};
    
    function closestColorName(r,g,b){
      const key = `${r},${g},${b}`;
      if(CALC_CACHE[key]) return CALC_CACHE[key];
      const lab = rgbToLab(r,g,b);
      let best = {name:'',hex:'#000000',dist:Infinity};
      for(const [name,hex] of Object.entries(CSS_COLORS)){
        const R = parseInt(hex.substr(1,2),16), G = parseInt(hex.substr(3,2),16), B = parseInt(hex.substr(5,2),16);
        const dist = deltaE76(lab, rgbToLab(R,G,B));
        if(dist < best.dist){ best = {name,hex,dist}; }
      }
      CALC_CACHE[key] = best;
      return best;
    }

    // Enhanced color naming with API integration
    async function getEnhancedColorName(r, g, b) {
      const hex = rgbToHex(r, g, b);
      const cacheKey = `api_${hex}`;
      
      // Check cache first
      if (API_CACHE[cacheKey]) {
        return API_CACHE[cacheKey];
      }
      
      try {
        // Try to get color name from The Color API
        const response = await fetch(`https://www.thecolorapi.com/id?hex=${hex.replace('#', '')}`);
        if (response.ok) {
          const data = await response.json();
          const apiResult = {
            name: data.name?.value || 'Unknown',
            hex: data.hex?.value || hex,
            dist: 0,
            source: 'API'
          };
          API_CACHE[cacheKey] = apiResult;
          return apiResult;
        }
      } catch (error) {
        console.log('API unavailable, using local matching');
      }
      
      // Fallback to local matching
      const localResult = closestColorName(r, g, b);
      localResult.source = 'Local';
      API_CACHE[cacheKey] = localResult;
      return localResult;
    }

    // DOM refs
    const startStopBtn = document.getElementById('startStopBtn');
    const detectNowBtn = document.getElementById('detectNowBtn');
    const uploadInput = document.getElementById('uploadInput');
    const modeCamera = document.getElementById('modeCamera');
    const modeUpload = document.getElementById('modeUpload');
    const continuousToggle = document.getElementById('continuousToggle');
    const video = document.getElementById('video');
    const previewImg = document.getElementById('previewImg');
    const buffer = document.getElementById('buffer');
    const magnCanvas = document.getElementById('magnCanvas');
    const magnifier = document.getElementById('magnifier');
    const floatingChip = document.getElementById('floatingChip');
    const chipSwatch = document.getElementById('chipSwatch');
    const chipName = document.getElementById('chipName');
    const chipMeta = document.getElementById('chipMeta');
    const bigSwatch = document.getElementById('bigSwatch');
    const colorNameEl = document.getElementById('colorName');
    const colorSubEl = document.getElementById('colorSub');
    const hexLabel = document.getElementById('hexLabel');
    const copyHexBtn = document.getElementById('copyHex');
    const exportBtn = document.getElementById('exportHistory');
    const clearBtn = document.getElementById('clearHistory');
    const historyList = document.getElementById('historyList');
    const fpsEl = document.getElementById('fps');
    const srLive = document.getElementById('srLive');
    const stageBody = document.getElementById('stageBody');
    const lockPointBtn = document.getElementById('lockPointBtn');
    let stream = null, anim = null;
    let continuousTimer = null;  // NEW: for interval detection
    let fpsCounter = {frames:0, lastTime: performance.now()};
    let history = [];
    const bufferCtx = buffer.getContext('2d');
    const magnCtx = magnCanvas.getContext('2d');
    // lock point state (stored as percent of buffer)
    let lockEnabled = false;
    let lockedPerc = {x:0.5, y:0.5}; // default center

    function rgbToHex(r,g,b){ return "#" + [r,g,b].map(v=> v.toString(16).padStart(2,'0')).join('').toUpperCase(); }
    function clamp(v){ return Math.max(0,Math.min(255,Math.round(v))); }
    async function updateDisplay(r,g,b, save=true){
      r = clamp(r); g = clamp(g); b = clamp(b);
      const hex = rgbToHex(r,g,b);
      
      // Update visual elements immediately
      bigSwatch.style.background = `rgb(${r}, ${g}, ${b})`;
      chipSwatch.style.background = `rgb(${r}, ${g}, ${b})`;
      hexLabel.textContent = hex;
      
      // Update color formats
      const hsl = rgbToHsl(r, g, b);
      const hsv = rgbToHsv(r, g, b);
      const cmyk = rgbToCmyk(r, g, b);
      
      document.getElementById('hslValue').textContent = `${hsl[0]}°, ${hsl[1]}%, ${hsl[2]}%`;
      document.getElementById('hsvValue').textContent = `${hsv[0]}°, ${hsv[1]}%, ${hsv[2]}%`;
      document.getElementById('cmykValue').textContent = `${cmyk[0]}%, ${cmyk[1]}%, ${cmyk[2]}%, ${cmyk[3]}%`;
      
      // Update color blindness simulation
      updateColorBlindnessSimulation(r, g, b);
      
      // Get color name (respect API toggle)
      const useAPI = document.getElementById('apiToggle').checked;
      const found = useAPI ? await getEnhancedColorName(r, g, b) : closestColorName(r, g, b);
      
      // Update name display
      colorNameEl.textContent = found.name;
      colorSubEl.textContent = `RGB (${r}, ${g}, ${b}) · HEX ${hex}`;
      chipName.textContent = found.name;
      chipMeta.textContent = `RGB (${r}, ${g}, ${b}) · ${hex}`;
      srLive.textContent = `Detected ${found.name}, ${hex}, RGB ${r} ${g} ${b}`;
      
      // Update source indicator
      document.getElementById('colorSource').textContent = found.source || 'Local';
      
      if(save) {
        pushHistory(found.name, r,g,b, hex);
        persistHistory();
      }
    }
    function pushHistory(name,r,g,b,hex){
      history.unshift({name,hex,time:new Date().toISOString()});
      if(history.length>40) history.length=40;
      renderHistory();
    }
    function renderHistory(){
      historyList.innerHTML = '';
      for(let i=0;i<history.length;i++){
        const h = history[i];
        const item = document.createElement('div');
        item.className = 'history-item';
        item.innerHTML = `<div class="hist-swatch" style="background:${h.hex}"></div>
                          <div class="hist-meta"><div class="hist-name">${h.name}</div><div class="hist-sub">${h.hex} · ${h.time.split('T')[1].slice(0,8)}</div></div>
                          <button class="copy-small" data-idx="${i}">Copy</button>`;
        item.addEventListener('click', (ev)=>{
          if(ev.target && ev.target.matches('button.copy-small')) return;
          const hex = h.hex.replace('#','');
          const r = parseInt(hex.slice(0,2),16), g = parseInt(hex.slice(2,4),16), b = parseInt(hex.slice(4,6),16);
          updateDisplay(r,g,b,false);
        });
        item.querySelector('button.copy-small').addEventListener('click', (ev)=>{
          ev.stopPropagation();
          navigator.clipboard.writeText(h.hex).then(()=> {
            const btn = ev.target;
            const old = btn.textContent; btn.textContent = 'Copied';
            setTimeout(()=> btn.textContent = old,900);
          });
        });
        historyList.appendChild(item);
      }
    }
    function persistHistory(){
      try{ localStorage.setItem('ts_history_v3', JSON.stringify(history)); }catch(e){}
    }
    function loadHistory(){
      try{
        const raw = localStorage.getItem('ts_history_v3');
        if(raw) history = JSON.parse(raw);
      }catch(e){}
      renderHistory();
    }
    // camera control
    async function startCamera(){
      try{
        if(previewImg.style.display !== 'none'){
          previewImg.style.display = 'none';
          previewImg.src = '';
          modeCamera.checked = true; modeUpload.checked = false;
        }
        stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
        video.srcObject = stream;
        video.style.display = '';
        startStopBtn.textContent = 'Stop Camera';
        setupDetectLoop();
      }catch(err){
        alert('Camera access denied or not available. Use upload instead.');
        console.error(err);
      }
    }
    function stopCamera(){
      if(stream){
        stream.getTracks().forEach(t=> t.stop());
        stream = null;
      }
      video.srcObject = null;
      video.style.display = 'none';
      startStopBtn.textContent = 'Start Camera';
      cancelAnimationFrame(anim); anim = null;
      clearInterval(continuousTimer); continuousTimer = null;
      fpsEl.textContent = '— FPS';
    }
    startStopBtn.addEventListener('click', ()=>{ if(!stream) startCamera(); else stopCamera(); });

    // detection loop with 2s interval for continuous mode
    function setupDetectLoop(){
      if(anim) return;
      const loop = (t)=>{
        anim = requestAnimationFrame(loop);
        fpsCounter.frames++;
        const elapsed = t - fpsCounter.lastTime;
        if(elapsed > 500){
          const fps = Math.round((fpsCounter.frames/(elapsed/1000)));
          fpsEl.textContent = `${fps} FPS`;
          fpsCounter.lastTime = t; fpsCounter.frames = 0;
        }
      };
      anim = requestAnimationFrame(loop);

      // Only one interval at a time!
      if(continuousTimer) clearInterval(continuousTimer);
      // If checked, start 2s interval detection
      if(continuousToggle.checked){
        continuousTimer = setInterval(()=>{
          if(!continuousToggle.checked) return;
          detectPoint();
        }, 2000);
      }
    }

    // Watch for toggle changes (start/stop interval)
    continuousToggle.addEventListener('change', ()=>{
      if(continuousTimer) { clearInterval(continuousTimer); continuousTimer = null; }
      if(continuousToggle.checked) {
        detectPoint();
        continuousTimer = setInterval(()=>{
          if(!continuousToggle.checked) return;
          detectPoint();
        }, 2000);
      }
    });

    function detectPoint(){
      const bufW = buffer.width || (video.videoWidth || stageBody.clientWidth);
      const bufH = buffer.height || (video.videoHeight || stageBody.clientHeight);
      if(stream && video.videoWidth){
        buffer.width = video.videoWidth; buffer.height = video.videoHeight;
        bufferCtx.drawImage(video,0,0,buffer.width,buffer.height);
      } else if(previewImg.style.display !== 'none'){
        buffer.width = previewImg.naturalWidth || previewImg.width;
        buffer.height = previewImg.naturalHeight || previewImg.height;
        bufferCtx.drawImage(previewImg,0,0,buffer.width,buffer.height);
      } else { return; }
      let bx, by;
      if(lockEnabled){
        bx = Math.floor(lockedPerc.x * buffer.width);
        by = Math.floor(lockedPerc.y * buffer.height);
      } else {
        bx = Math.floor(buffer.width/2);
        by = Math.floor(buffer.height/2);
      }
      try{
        const p = bufferCtx.getImageData(bx,by,1,1).data;
        updateDisplay(p[0],p[1],p[2]);
        showFloating();
      }catch(e){}
    }
    // show floating chip briefly
    function showFloating(){
      floatingChip.classList.remove('hidden');
      clearTimeout(floatingChip._hide);
      floatingChip._hide = setTimeout(()=> floatingChip.classList.add('hidden'), 1100);
    }
    detectNowBtn.addEventListener('click', ()=>{ detectPoint(); if(!anim && stream) setupDetectLoop(); });
    // file upload behavior: stop camera automatically and show preview; detect center of uploaded image
    uploadInput.addEventListener('change', (ev)=>{
      const f = ev.target.files[0];
      if(!f) return;
      if(stream) stopCamera();
      const url = URL.createObjectURL(f);
      previewImg.onload = ()=>{
        previewImg.style.display = '';
        video.style.display = 'none';
        modeUpload.checked = true;
        modeCamera.checked = false;
        buffer.width = previewImg.naturalWidth;
        buffer.height = previewImg.naturalHeight;
        bufferCtx.drawImage(previewImg,0,0,buffer.width,buffer.height);
        if(!lockEnabled){
          lockedPerc.x = 0.5; lockedPerc.y = 0.5;
        }
        detectPoint();
        URL.revokeObjectURL(url);
      };
      previewImg.onerror = ()=> alert('Failed to load image');
      previewImg.src = url;
    });
    // pointer/magnifier logic (works for mouse & touch)
    function handlePointerMove(clientX, clientY){
      const rect = stageBody.getBoundingClientRect();
      const x = clientX - rect.left, y = clientY - rect.top;
      const show = (previewImg.style.display !== 'none') || (video.style.display !== 'none' && video.videoWidth);
      if(!show){ magnifier.style.display = 'none'; return; }
      magnifier.style.display = 'block';
      let left = clientX + 14;
      if(left + magnifier.offsetWidth > window.innerWidth - 24) left = clientX - magnifier.offsetWidth - 14;
      magnifier.style.left = left + 'px';
      magnifier.style.top = (clientY - magnifier.offsetHeight/2) + 'px';
      const displayW = stageBody.clientWidth, displayH = stageBody.clientHeight;
      const bufW = buffer.width || (video.videoWidth || displayW), bufH = buffer.height || (video.videoHeight || displayH);
      const scaleX = bufW / displayW, scaleY = bufH / displayH;
      const sampleSize = 60;
      const bx = Math.floor(x * scaleX - sampleSize/2);
      const by = Math.floor(y * scaleY - sampleSize/2);
      magnCanvas.width = 120; magnCanvas.height = 120;
      try{
        const sx = Math.max(0, bx), sy = Math.max(0, by);
        const sWidth = Math.min(sampleSize, bufW - sx), sHeight = Math.min(sampleSize, bufH - sy);
        magnCtx.imageSmoothingEnabled = false;
        magnCtx.clearRect(0,0,magnCanvas.width,magnCanvas.height);
        magnCtx.drawImage(buffer, sx, sy, sWidth, sHeight, 0,0, magnCanvas.width, magnCanvas.height);
        magnCtx.strokeStyle = 'rgba(255,255,255,0.9)'; magnCtx.lineWidth = 2;
        magnCtx.beginPath(); magnCtx.moveTo(60,0); magnCtx.lineTo(60,120); magnCtx.moveTo(0,60); magnCtx.lineTo(120,60); magnCtx.stroke();
      }catch(e){}
    }
    stageBody.addEventListener('mousemove', (e)=> { handlePointerMove(e.clientX, e.clientY); });
    stageBody.addEventListener('touchmove', (e)=>{ if(e.touches && e.touches[0]){ handlePointerMove(e.touches[0].clientX, e.touches[0].clientY); } });
    stageBody.addEventListener('mouseleave', ()=> { magnifier.style.display = 'none'; });
    // click to pick / set locked point
    stageBody.addEventListener('click', (e)=>{
      const rect = stageBody.getBoundingClientRect();
      const x = e.clientX - rect.left, y = e.clientY - rect.top;
      const displayW = stageBody.clientWidth, displayH = stageBody.clientHeight;
      const bufW = buffer.width || (video.videoWidth || displayW), bufH = buffer.height || (video.videoHeight || displayH);
      const scaleX = bufW / displayW, scaleY = bufH / displayH;
      const bx = Math.floor(x * scaleX), by = Math.floor(y * scaleY);
      if(lockEnabled){
        lockedPerc.x = bx / bufW; lockedPerc.y = by / bufH;
        const cross = document.querySelector('.center-cross');
        cross.style.left = `${x}px`; cross.style.top = `${y}px`; cross.style.transform = 'translate(-50%,-50%)';
        detectPoint(); showFloating();
        return;
      }
      try{
        const p = bufferCtx.getImageData(bx,by,1,1).data;
        updateDisplay(p[0], p[1], p[2]);
        showFloating();
      }catch(err){
        if(stream && video.videoWidth){
          buffer.width = video.videoWidth; buffer.height = video.videoHeight;
          bufferCtx.drawImage(video,0,0);
          try{
            const p = bufferCtx.getImageData(bx,by,1,1).data;
            updateDisplay(p[0],p[1],p[2]); showFloating();
          }catch(e){}
        }
      }
    });
    stageBody.addEventListener('touchend', (e)=>{
      if(!e.changedTouches || !e.changedTouches[0]) return;
      const t = e.changedTouches[0];
      const rect = stageBody.getBoundingClientRect();
      const x = t.clientX - rect.left, y = t.clientY - rect.top;
      const displayW = stageBody.clientWidth, displayH = stageBody.clientHeight;
      const bufW = buffer.width || (video.videoWidth || displayW), bufH = buffer.height || (video.videoHeight || displayH);
      const bx = Math.floor(x * (bufW/displayW)), by = Math.floor(y * (bufH/displayH));
      if(lockEnabled){
        lockedPerc.x = bx / bufW; lockedPerc.y = by / bufH; detectPoint(); showFloating(); return;
      }
      try{ const p = bufferCtx.getImageData(bx, by,1,1).data; updateDisplay(p[0],p[1],p[2]); showFloating(); }catch(e){}
    });
    // lock point toggle
    lockPointBtn.addEventListener('click', ()=>{
      lockEnabled = !lockEnabled;
      lockPointBtn.textContent = `Lock Point: ${lockEnabled? 'On' : 'Off'}`;
      lockPointBtn.style.background = lockEnabled ? 'linear-gradient(90deg,#10b981,#059669)' : '';
      if(lockEnabled){
        const bufW = buffer.width || (video.videoWidth || stageBody.clientWidth);
        const bufH = buffer.height || (video.videoHeight || stageBody.clientHeight);
        lockedPerc.x = 0.5; lockedPerc.y = 0.5;
      } else {
        const cross = document.querySelector('.center-cross');
        cross.style.left = '50%'; cross.style.top = '50%'; cross.style.transform = 'translate(-50%,-50%)';
      }
    });
    // copy hex
    copyHexBtn.addEventListener('click', ()=>{
      const txt = hexLabel.textContent.trim();
      navigator.clipboard.writeText(txt).then(()=> {
        copyHexBtn.textContent = 'Copied';
        setTimeout(()=> copyHexBtn.textContent = 'Copy HEX',900);
      });
    });
    // export history
    exportBtn.addEventListener('click', ()=>{
      if(!history.length){ alert('No history to export'); return; }
      let fmt = prompt('Export format? Type "csv" or "json" (default json):','json');
      if(!fmt) fmt = 'json';
      fmt = fmt.toLowerCase().trim();
      if(fmt === 'csv'){
        const rows = [['name','hex','time']];
        for(const h of history) rows.push([h.name,h.hex,h.time]);
        const csv = rows.map(r => r.map(cell => `"${String(cell).replace(/"/g,'""')}"`).join(',')).join('\n');
        const blob = new Blob([csv], {type:'text/csv'}); const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = 'trueShade_history.csv'; a.click(); URL.revokeObjectURL(url);
      } else {
        const compact = history.map(h => ({name:h.name,hex:h.hex,time:h.time}));
        const blob = new Blob([JSON.stringify(compact, null, 2)], {type:'application/json'}); const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = 'trueShade_history.json'; a.click(); URL.revokeObjectURL(url);
      }
    });
    // clear history
    clearBtn.addEventListener('click', ()=>{
      if(confirm('Clear color history?')){ history = []; persistHistory(); renderHistory(); }
    });
    // stop camera on unload
    window.addEventListener('beforeunload', ()=> { if(stream) stopCamera(); });
    setTimeout(()=> {
      if(!localStorage.getItem('ts_seen_v3')){
        alert('Tip: Upload stops camera automatically. Tap/click preview to pick or to set the locked point. Use Continuous for live tracking.');
        localStorage.setItem('ts_seen_v3','1');
      }
    },700);
    video.addEventListener('play', function(){
      const tick = ()=>{ if(video.paused || video.ended) return; if(video.videoWidth){ buffer.width = video.videoWidth; buffer.height = video.videoHeight; bufferCtx.drawImage(video,0,0, buffer.width, buffer.height); } requestAnimationFrame(tick); };
      requestAnimationFrame(tick);
    });
    window.addEventListener('keydown', (e)=>{
      if(e.key === ' '){ e.preventDefault(); detectPoint(); }
      if(e.key === 'c'){ continuousToggle.checked = !continuousToggle.checked; continuousToggle.dispatchEvent(new Event('change')); }
      if(e.key === 'l'){ lockEnabled = !lockEnabled; lockPointBtn.textContent = `Lock Point: ${lockEnabled? 'On' : 'Off'}`; }
      if(e.key === 'p'){ document.getElementById('generatePaletteBtn').click(); }
      if(e.key === 'b'){ document.getElementById('batchModeBtn').click(); }
      if(e.key === 'a'){ document.getElementById('apiToggle').checked = !document.getElementById('apiToggle').checked; }
      if(e.key === 'n'){ document.getElementById('addCustomNameBtn').click(); }
    });

    // Enhanced Features Implementation
    
    // Color Blindness Simulation
    function updateColorBlindnessSimulation(r, g, b) {
      const colorBlindType = document.getElementById('colorBlindSelect').value;
      const normalSwatch = document.getElementById('normalSwatch');
      const simulatedSwatch = document.getElementById('simulatedSwatch');
      
      normalSwatch.style.background = `rgb(${r}, ${g}, ${b})`;
      
      if (colorBlindType === 'normal') {
        simulatedSwatch.style.background = `rgb(${r}, ${g}, ${b})`;
      } else {
        const simulated = simulateColorBlindness(r, g, b, colorBlindType);
        simulatedSwatch.style.background = `rgb(${Math.round(simulated[0])}, ${Math.round(simulated[1])}, ${Math.round(simulated[2])})`;
      }
    }

    // Color Palette Generation
    function renderPalette(palette, containerId) {
      const container = document.getElementById(containerId);
      container.innerHTML = '';
      
      palette.forEach(color => {
        const colorDiv = document.createElement('div');
        colorDiv.className = 'palette-color';
        colorDiv.style.background = `rgb(${color.rgb[0]}, ${color.rgb[1]}, ${color.rgb[2]})`;
        colorDiv.setAttribute('data-name', color.name);
        colorDiv.addEventListener('click', () => {
          updateDisplay(color.rgb[0], color.rgb[1], color.rgb[2]);
        });
        container.appendChild(colorDiv);
      });
    }

    // History Search
    function filterHistory(searchTerm) {
      const items = document.querySelectorAll('.history-item');
      items.forEach(item => {
        const name = item.querySelector('.hist-name').textContent.toLowerCase();
        const hex = item.querySelector('.hist-sub').textContent.toLowerCase();
        const matches = name.includes(searchTerm.toLowerCase()) || hex.includes(searchTerm.toLowerCase());
        item.style.display = matches ? 'flex' : 'none';
      });
    }

    // Custom Color Names
    let customNames = JSON.parse(localStorage.getItem('ts_custom_names') || '[]');

    function renderCustomNames() {
      const container = document.getElementById('customNamesList');
      container.innerHTML = '';
      
      customNames.forEach((custom, index) => {
        const item = document.createElement('div');
        item.className = 'custom-name-item';
        item.innerHTML = `
          <div class="custom-name-swatch" style="background:${custom.hex}"></div>
          <div style="flex:1;font-weight:700;">${custom.name}</div>
          <div style="font-size:10px;color:var(--muted);">${custom.hex}</div>
          <button class="copy-small" style="font-size:10px;padding:2px 6px;" onclick="navigator.clipboard.writeText('${custom.hex}')">Copy</button>
          <button class="copy-small" style="font-size:10px;padding:2px 6px;background:var(--danger);" onclick="removeCustomName(${index})">×</button>
        `;
        container.appendChild(item);
      });
    }

    function addCustomName(name, hex) {
      customNames.push({ name, hex, time: new Date().toISOString() });
      localStorage.setItem('ts_custom_names', JSON.stringify(customNames));
      renderCustomNames();
    }

    function removeCustomName(index) {
      customNames.splice(index, 1);
      localStorage.setItem('ts_custom_names', JSON.stringify(customNames));
      renderCustomNames();
    }

    // Batch Processing
    let batchImages = [];
    let batchMode = false;

    function toggleBatchMode() {
      batchMode = !batchMode;
      const batchUpload = document.getElementById('batchUpload');
      const batchModeBtn = document.getElementById('batchModeBtn');
      
      if (batchMode) {
        batchUpload.style.display = 'block';
        batchModeBtn.style.background = 'linear-gradient(90deg,var(--success),#059669)';
        batchModeBtn.textContent = 'Exit Batch';
      } else {
        batchUpload.style.display = 'none';
        batchModeBtn.style.background = '';
        batchModeBtn.textContent = 'Batch';
        batchImages = [];
        document.getElementById('batchPreview').innerHTML = '';
      }
    }

    function processBatchImage(file) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);
          
          // Sample center color
          const centerX = Math.floor(img.width / 2);
          const centerY = Math.floor(img.height / 2);
          const pixelData = ctx.getImageData(centerX, centerY, 1, 1).data;
          
          resolve({
            name: file.name,
            rgb: [pixelData[0], pixelData[1], pixelData[2]],
            hex: rgbToHex(pixelData[0], pixelData[1], pixelData[2]),
            url: URL.createObjectURL(file)
          });
        };
        img.src = URL.createObjectURL(file);
      });
    }

    // Enhanced Export with PNG/SVG
    function exportColorSwatch(format) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 200;
      canvas.height = 200;
      
      const currentColor = bigSwatch.style.background;
      ctx.fillStyle = currentColor;
      ctx.fillRect(0, 0, 200, 200);
      
      if (format === 'png') {
        canvas.toBlob(blob => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `color_${hexLabel.textContent.replace('#', '')}.png`;
          a.click();
          URL.revokeObjectURL(url);
        });
      } else if (format === 'svg') {
        const svg = `
          <svg width="200" height="200" xmlns="http://www.w3.org/2000/svg">
            <rect width="200" height="200" fill="${currentColor}"/>
            <text x="100" y="100" text-anchor="middle" fill="white" font-family="Arial" font-size="14">${hexLabel.textContent}</text>
          </svg>
        `;
        const blob = new Blob([svg], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `color_${hexLabel.textContent.replace('#', '')}.svg`;
        a.click();
        URL.revokeObjectURL(url);
      }
    }

    // Event Listeners for Enhanced Features
    document.getElementById('generatePaletteBtn').addEventListener('click', () => {
      const currentRgb = bigSwatch.style.background.match(/\d+/g);
      if (currentRgb) {
        const r = parseInt(currentRgb[0]);
        const g = parseInt(currentRgb[1]);
        const b = parseInt(currentRgb[2]);
        const palette = generatePalette(r, g, b);
        
        // Update hex values for palette colors
        Object.keys(palette).forEach(key => {
          palette[key].forEach(color => {
            if (!color.hex) {
              color.hex = rgbToHex(color.rgb[0], color.rgb[1], color.rgb[2]);
            }
          });
        });
        
        renderPalette(palette.complementary, 'complementaryPalette');
        renderPalette(palette.analogous, 'analogousPalette');
        renderPalette(palette.triadic, 'triadicPalette');
        renderPalette(palette.tetradic, 'tetradicPalette');
        
        document.getElementById('paletteContainer').style.display = 'block';
      }
    });

    document.getElementById('colorBlindSelect').addEventListener('change', () => {
      const currentRgb = bigSwatch.style.background.match(/\d+/g);
      if (currentRgb) {
        updateColorBlindnessSimulation(parseInt(currentRgb[0]), parseInt(currentRgb[1]), parseInt(currentRgb[2]));
      }
    });

    document.getElementById('historySearch').addEventListener('input', (e) => {
      filterHistory(e.target.value);
    });

    document.getElementById('clearSearchBtn').addEventListener('click', () => {
      document.getElementById('historySearch').value = '';
      filterHistory('');
    });

    document.getElementById('addCustomNameBtn').addEventListener('click', () => {
      const name = prompt('Enter custom color name:');
      if (name && name.trim()) {
        addCustomName(name.trim(), hexLabel.textContent);
      }
    });

    document.getElementById('batchModeBtn').addEventListener('click', toggleBatchMode);

    document.getElementById('batchInput').addEventListener('change', async (e) => {
      const files = Array.from(e.target.files);
      for (const file of files) {
        const result = await processBatchImage(file);
        batchImages.push(result);
      }
      renderBatchPreview();
    });

    document.getElementById('processBatchBtn').addEventListener('click', () => {
      batchImages.forEach(img => {
        pushHistory(`Batch: ${img.name}`, img.rgb[0], img.rgb[1], img.rgb[2], img.hex);
      });
      persistHistory();
      alert(`Processed ${batchImages.length} images!`);
    });

    document.getElementById('clearBatchBtn').addEventListener('click', () => {
      batchImages.forEach(img => URL.revokeObjectURL(img.url));
      batchImages = [];
      renderBatchPreview();
    });

    function renderBatchPreview() {
      const container = document.getElementById('batchPreview');
      container.innerHTML = '';
      
      batchImages.forEach((img, index) => {
        const item = document.createElement('div');
        item.className = 'batch-item';
        item.style.background = `rgb(${img.rgb[0]}, ${img.rgb[1]}, ${img.rgb[2]})`;
        item.addEventListener('click', () => {
          updateDisplay(img.rgb[0], img.rgb[1], img.rgb[2]);
        });
        item.addEventListener('click', (e) => {
          if (e.target.tagName === 'DIV' && e.target.textContent === '×') {
            batchImages.splice(index, 1);
            URL.revokeObjectURL(img.url);
            renderBatchPreview();
          }
        });
        container.appendChild(item);
      });
    }

    // Enhanced export with additional formats
    const originalExportBtn = document.getElementById('exportHistory');
    originalExportBtn.addEventListener('click', () => {
      if(!history.length){ alert('No history to export'); return; }
      
      const exportOptions = document.createElement('div');
      exportOptions.className = 'export-options';
      exportOptions.innerHTML = `
        <button class="btn" onclick="exportHistory('json')">JSON</button>
        <button class="btn" onclick="exportHistory('csv')">CSV</button>
        <button class="btn" onclick="exportColorSwatch('png')">PNG</button>
        <button class="btn" onclick="exportColorSwatch('svg')">SVG</button>
      `;
      
      // Replace the original export functionality
      function exportHistory(format) {
        if(format === 'csv'){
          const rows = [['name','hex','time']];
          for(const h of history) rows.push([h.name,h.hex,h.time]);
          const csv = rows.map(r => r.map(cell => `"${String(cell).replace(/"/g,'""')}"`).join(',')).join('\n');
          const blob = new Blob([csv], {type:'text/csv'}); const url = URL.createObjectURL(blob);
          const a = document.createElement('a'); a.href = url; a.download = 'trueShade_history.csv'; a.click(); URL.revokeObjectURL(url);
        } else {
          const compact = history.map(h => ({name:h.name,hex:h.hex,time:h.time}));
          const blob = new Blob([JSON.stringify(compact, null, 2)], {type:'application/json'}); const url = URL.createObjectURL(blob);
          const a = document.createElement('a'); a.href = url; a.download = 'trueShade_history.json'; a.click(); URL.revokeObjectURL(url);
        }
      }
      
      // Show export options
      const existingOptions = document.querySelector('.export-options');
      if (existingOptions) existingOptions.remove();
      originalExportBtn.parentNode.appendChild(exportOptions);
    });

    // Initialize enhanced features
    renderCustomNames();
    loadHistory();
  </script>
</body>
</html>
